function handles = IdentifyPrimLoG(handles)

% Help for the Identify Primary LoG module:
% Category: Object Processing
%
% SHORT DESCRIPTION:
%
% Changed by Berend Snijder to try and make iBRAIN / old CellProfiler
% compatible!!!
%
% Identifies the centers of blob-like primary objects.  The result
% consists of only a single pixel per object, located near the center
% of the object.
%
% *************************************************************************
%
% This module identifies the centers of blob-like primary objects
% (e.g. nuclei) in grayscale images that show bright objects on a dark
% background.  When the objects of interest are fairly round and of
% even size, this module may be more sensitive than the methods in
% IdentifyPrimAutomatic and therefore detect objects that would
% otherwise be lost.
% 
% The result consists of only a single pixel per object, located near
% the center of the object; the IdentifySecondary module can be used
% to fill out the object based on this center point.
%
% SETTINGS:
%
% The radius parameter should be set to the approximate radius of the
% objects of interest.  The algorithm is not very sensitive to this
% parameter.
%
% The threshold parameter informs the algorithm how inclusive to be when
% looking for objects.  Internally, each potential object is assigned
% a score that depends on both how bright the object is and how
% blob-like its shape is.  Only objects that score above the threshold
% are returned.  If the thresold is too high, objects will be lost; 
% if it is too low, spurious objects will be found. The threshold 
% can be determined experimentally, but the 'Automatic' setting 
% will make a guess using RobustBackground Global's thresholding 
% method on the transformed image.  RobustBackground is useful because it
% makes little assumption of the intensity histogram, and thus 
% can be protective against out-of-focus or empty images.  If you want the 
% threshold to be consistent across images, then you can use the threshold found by 
% the 'Automatic' setting as a starting point for manual threshold input adjustment.
% Also, if the threshold is consistently high or low, then you can adjust 
% by a multiplicative correction factor by inserting it after a comma, e.g.
% "Automatic,1.5". 
%
% ALGORITHM DETAILS:
%
% The module works by convolving the image with the Laplacian of
% Gaussian (LoG) kernel.  This is equivalent to convolving with the
% Gaussian kernel and then with the Laplace operator.  The regional
% maxima in the filter response that exceed the specificed threshold
% are identified as objects.  The radius parameter specifies the width
% of the kernel.
%
% Ultimately, this module will become an option in
% IdentifyPrimAutomatic, so that its options for maxima suppression
% and finding edges between clumps can be used.
%
% $Revision: 7941 $

%%%%%%%%%%%%%%%%%
%%% VARIABLES %%%
%%%%%%%%%%%%%%%%%

% Notes for PyCP
%
% FROM CP ToDo:
% Anne 2008_01_30: Merge IdentifyPrimaryLoG into the regular IdentifyPrimAutomatic module. 
% In particular, be sure that the help describes under what conditions the different options 
% are useful. Think carefully about how to add the variable that is LoG-specific to the module.
%
% Anne 2008_05_12: Describe what the LoG is doing - we think that we are looking for 
% minima (or maxima) of the LoG which makes it a maxima-minima finder of the original image, 
% whereas many people look for zero crossings of the LoG which would be using it as an edge 
% detector. Is that right?
%
% David 2009_04_17:  As the above older comments say, this module should be integrated into
% IDPrimAuto.  However, this ID module is different than other primary segmentation modules
% in that it only finds the center pixel of objects and must utilize a subsequent IDSecondary 
% after to grow objects.  So we either:
% (1) Treat LoG as a special thresholding method that only ouputs single pixel objects
% or
% (2) Treat LoG as a declumping method.  In this case, another thresholding method would define 
% foreground/background, and LoG would find single pixels within the foreground.
% 
% In either case, we would need to decide whether we automatically apply a watershed/propagation
% after the initial single-pixel finding method.  I prefer (2) above and would opt for
% automatically propagating the single-pixels within the foreground objects, since that is almost 
% always done anyway, and would save the step of adding an IDSecondary.
%
% Settings:
% The first two settings map obviously.
% The diameter parameter is only single, so that if LoG is chosen, one of the diameter boxes 
% should gray-out.
% The threshold parameter is very sensitive, and the user was blind to what this should be at first,
% so the 'Automatic' threshold was added recently to use Otsu to guess.  This functionality would be
% equivalent to the 'Automatic' setting in the existing declumping settings.

drawnow

[CurrentModule, CurrentModuleNum, ModuleName] = CPwhichmodule(handles);

%textVAR01 = What did you call the images you want to process?
%infotypeVAR01 = imagegroup
ImageName = char(handles.Settings.VariableValues{CurrentModuleNum,1});
%inputtypeVAR01 = popupmenu

%textVAR02 = What do you want to call the objects identified by this module?
%defaultVAR02 = Nuclei
%infotypeVAR02 = objectgroup indep
ObjectName = char(handles.Settings.VariableValues{CurrentModuleNum,2});

%textVAR03 = Typical diameter of objects, in pixel units:
%defaultVAR03 = 10
Radius = char(handles.Settings.VariableValues{CurrentModuleNum,3});

%textVAR04 = Score threshold for match.  Enter a number, leave as 'Automatic', or adjust the Automatic threshold with a multiplicative correction factor (separating comma is necessary), e.g. 'Automatic,1.2'.
%defaultVAR04 = Automatic
ThresholdStr = char(handles.Settings.VariableValues{CurrentModuleNum,4});

%%%VariableRevisionNumber = 1

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% PRELIMINARY ERROR CHECKING & FILE HANDLING %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
drawnow

OrigImage = double(CPretrieveimage(handles,ImageName,ModuleName,'MustBeGray','CheckScale'));
Radius = str2double(Radius);

%%%%%%%%%%%%%%%%%%%%%%
%%% IMAGE ANALYSIS %%%
%%%%%%%%%%%%%%%%%%%%%%
drawnow

im = double(OrigImage) - double(min(OrigImage(:)));
if any(im(:))
    im = im / max(im(:));
end

% % Set regions outside of CropMasks equal to 0
% MaskFieldname = ['CropMask', ImageName];
% if CPisimageinpipeline(handles, MaskFieldname)
%     %%% Retrieves previously selected cropping mask from handles
%     %%% structure.
%     PreviousCropMask = CPretrieveimage(handles,MaskFieldname,ModuleName);
%     try 
%         im(~PreviousCropMask) = 0;
%     catch
%         error('The image in which you want to identify objects has been cropped, but there was a problem recognizing the cropping pattern.');
%     end
% end

ac = lapofgau(1 - im, Radius);

% IntermediateImage = ac - min(ac(:));
% %%% The maximum of the image is brought to 1.
% ac_scaled = IntermediateImage ./ max(IntermediateImage(:));

ac_min = min(ac(:));
ac_range = max(ac(:)) - ac_min;
ac_scaled = (ac - ac_min) ./ ac_range;

if ~isnan(str2double(ThresholdStr))
    Threshold = str2double(ThresholdStr);
elseif strcmpi('Automatic',ThresholdStr(1:9))
    if numel(ThresholdStr) > length('Automatic')
        assert(strcmp(ThresholdStr(10),','),'A comma must follow ''Automatic'' if a threshold correction factor is used.')
        Threshold_correction = str2double(ThresholdStr(length('Automatic')+1:end));
    else
        Threshold_correction = 1;
    end
    [handles,Threshold_scaled] = CPthreshold(handles,'RobustBackground Global',0,'0','1',Threshold_correction,ac_scaled,'LoG',ModuleName);

    %% Un-scale threshold
    Threshold = (Threshold_scaled .* ac_range) + ac_min;
end

ac(ac < Threshold) = Threshold;
ac = ac - Threshold;

bw = false(size(im));
if any(ac(:))
    indices = find(imregionalmax(ac));
    maxima = sortrows([indices ac(indices)], -2);
    bw(maxima(:,1)) = true;
end

%% Mask final outcome
if exist('PreviousCropMask','var')
    bw = bw & PreviousCropMask;
end

FinalLabelMatrixImage = bwlabel(bw);

% The dilated mask is used only for visualization.
dilated = imdilate(bw, strel('disk', 2));
vislabel = bwlabel(dilated);
r = OrigImage;
g = OrigImage;
b = OrigImage;
r(dilated) = 1;
g(dilated) = 0;
b(dilated) = 0;
visRGB = cat(3, r, g, b);

%%%%%%%%%%%%%%%%%%%%%%%
%%% DISPLAY RESULTS %%%
%%%%%%%%%%%%%%%%%%%%%%%
drawnow

ThisModuleFigureNumber = handles.Current.(['FigureNumberForModule',CurrentModule]);
if any(findobj == ThisModuleFigureNumber)
  h_fig = CPfigure(handles,'Image',ThisModuleFigureNumber);
  hImage = CPimagesc(visRGB, handles);
  hAx = gca;
  title(hAx,[ObjectName, ' cycle # ',num2str(handles.Current.SetBeingAnalyzed)]);
  
  ud(1).img = visRGB;
  ud(2).img = ac_scaled;
  ud(3).img = OrigImage;
  ud(1).title = [ObjectName ' , cycle # ',num2str(handles.Current.SetBeingAnalyzed)];
  ud(2).title = ['Laplacian of Gaussian transformed ' ObjectName ', cycle # ',num2str(handles.Current.SetBeingAnalyzed)];
  ud(3).title = ['Input Image, cycle # ',num2str(handles.Current.SetBeingAnalyzed)];
  uicontrol(h_fig, 'Style', 'popup',...
                    'String', 'Objects on Original Image|Laplacian of Gaussian Transformed|Input Image',...
                    'UserData',ud,...
                    'units','normalized',...
                    'position',[.01 .95 .25 .04],...
                    'backgroundcolor',[.7 .7 .9],...
                    'tag','PopupImage',...
                    'Callback', @CP_ImagePopupmenu_Callback);
  
  text(0.1,-0.08,...
      ['Threshold: ' num2str(Threshold) ', Number of objects: ' num2str(sum(bw(:)))],...
      'Color','black',...
      'fontsize',handles.Preferences.FontSize,...
      'Units','Normalized',...
      'Parent',hAx);
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% SAVE DATA TO HANDLES STRUCTURE %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
drawnow

prefixes = {'Segmented', 'SmallRemovedSegmented'};
for i=1:length(prefixes)
  prefix = prefixes{i};
  fieldname = [prefix, ObjectName];
  handles = CPaddimages(handles,fieldname,FinalLabelMatrixImage);
end

handles = CPsaveObjectCount(handles, ObjectName, FinalLabelMatrixImage);
handles = CPsaveObjectLocations(handles, ObjectName, FinalLabelMatrixImage);

function f = lapofgau(im, s)
% im: image matrix (2 dimensional)
% s: filter width
% f: filter output.
% Author: Baris Sumengen - sumengen@ece.ucsb.edu

sigma = (s-1)/3;
op = fspecial('log',s,sigma); 
op = op - sum(op(:))/numel(op); % make the op to sum to zero

%% Pad image to fix border artifact
padsize = ceil(s./2);
im = padarray(im,[padsize padsize],'replicate');

%% Use 'single' here, since imfilter is optimized on Intel chips for
%% certain array classes (see Matlab documentation)
f = double(imfilter(single(im),op));

%% Crop pad
f = f(padsize+1:end-padsize,padsize+1:end-padsize);

function handles = CPaddimages(handles, varargin)
% Add images to the handles.Pipeline structure.
% Location will be "handles.Pipeline.ImageName".

% CellProfiler is distributed under the GNU General Public License.
% See the accompanying file LICENSE for details.
%
% Developed by the Whitehead Institute for Biomedical Research.
% Copyright 2003,2004,2005.
%
% Please see the AUTHORS file for credits.
%
% Website: http://www.cellprofiler.org
%
% $Revision: 7247 $

% Parse out varargin. The added data can be numeric, logical or a structure
% (e.g, movie)
if mod(length(varargin),2) ~= 0 || ...
   ~all(cellfun(@ischar,varargin(1:2:end)) & ...
   (cellfun(@isnumeric,varargin(2:2:end)) | cellfun(@islogical,varargin(2:2:end)) | cellfun(@isstruct,varargin(2:2:end))))
    error('The argument list must be of the form: ''ImageName1'', ImageData1, etc');
else
    ImageName = varargin(1:2:end);
    ImageData = varargin(2:2:end);
end

CPvalidfieldname(ImageName);

% Checks have passed, add the data
if ~isfield(handles.Pipeline,'ImageGroupFields')
    % If no image groups, add to the handles.Pipeline structure
    for i = 1:length(ImageName)
        handles.Pipeline.(ImageName{i}) = ImageData{i};
    end
else
    % If no image groups, add to the appropriate
    % handles.Pipeline.GroupFileList structure
    for i = 1:length(ImageName)
        handles.Pipeline.GroupFileList{handles.Pipeline.CurrentImageGroupID}.(ImageName{i}) = ImageData{i};
    end
end


function CPvalidfieldname(fieldname)

% Throw an error if the field name does not start with
% an alphabetic character, if it contains characters other
% than alphanumerics and underbar or if it is more than 63
% characters long.

% $Revision: 5791 $

if length(fieldname) > namelengthmax
    error(['The field name, "',fieldname,'", is more than ',num2str(namelengthmax),' characters long.']);
end
if isempty(regexp(fieldname,'^[A-Za-z]', 'once' ))
    error(['The field name, "',fieldname,'", does not start with an alphabetic character.']);
end
if isempty(regexp(fieldname,'^[A-Za-z][A-Za-z0-9_]{0,62}$', 'once' ))
    error(['The field name, "',fieldname,'", contains characters other than alphanumerics and "_"']);
end

% CPSAVEOBJECTCOUNT Save the count of segmented objects.
%   The function returns a new version of the handles structure, in which
%   the number of segmented objects has been saved.
%
%   Example:
%      handles = CPsaveObjectCount(handles, 'Cells', labelMatrix)
%      creates handles.Measurements.Cells{i}.Count_Cells.
function handles = CPsaveObjectCount(handles, objectName, labels)
%
% CellProfiler is distributed under the GNU General Public License.
% See the accompanying file LICENSE for details.
%
% Developed by the Whitehead Institute for Biomedical Research.
% Copyright 2008.
%
% Please see the AUTHORS file for credits.
%
% Website: http://www.cellprofiler.org
%
% $Revision: 5777 $
% handles = CPaddmeasurements(handles, 'Image', CPjoinstrings('Count', objectName), CPjoinstrings('Count', objectName), max(labels(:)));
handles = CPaddmeasurements(handles, 'Image', CPjoinstrings('Count', objectName), max(labels(:)));

            
            
function handles = CPsaveObjectLocations(handles, objectName, labels)
% CPSAVEOBJECTLOCATIONS Save the location of each segmented object.
%   The function returns a new version of the handles structure, in
%   which the location of each segmented object has been saved.
%
%   Example:
%      handles = CPsaveObjectLocations(handles, 'Cells', cellLabelMatrix)
%      creates handles.Measurements.Cells{1}.Location_Center_X and
%      handles.Measurements.Cells{1}.Location_Center_Y.
%
% CellProfiler is distributed under the GNU General Public License.
% See the accompanying file LICENSE for details.
%
% Developed by the Whitehead Institute for Biomedical Research.
% Copyright 2008.
%
% Please see the AUTHORS file for credits.
%
% Website: http://www.cellprofiler.org
%
% $Revision: 5777 $
tmp = regionprops(labels, 'Centroid');
centroids = cat(1,tmp.Centroid);
if isempty(centroids)
  centroids = zeros(0,2);
end
% % handles = CPaddmeasurements(handles,Object,   Measure,                Feature,            Data)
% handles = CPaddmeasurements(handles, objectName, 'Location_Center_X', 'Location_Center_X', centroids(:,1));
% handles = CPaddmeasurements(handles, objectName, 'Location_Center_Y', 'Location_Center_Y', centroids(:,2));
% handles = CPaddmeasurements(handles,Object,   Measure,                Feature,            Data)
handles = CPaddmeasurements(handles, objectName, 'Location_Center_X', centroids(:,1));
handles = CPaddmeasurements(handles, objectName, 'Location_Center_Y', centroids(:,2));
                        
function string = CPjoinstrings(varargin)
%CPjoinstrings Build underscore-separated string from parts.
%
%   CPjoinstrings(D1,D2, ... ) builds a string from 
%   D1,D2, etc specified.  This is conceptually equivalent to
%
%      F = [D1 '_' D2 '_' ... '_' DN] 
%
%   Care is taken to handle the cases where the directory
%   parts D1, D2, etc. may contain an empty string, in which case there are
%   not two consecutive underscores output.
%
%   Examples
%   See also FILESEP, PATHSEP, FILEPARTS.

% CellProfiler is distributed under the GNU General Public License.
% See the accompanying file LICENSE for details.
%
% Developed by the Whitehead Institute for Biomedical Research.
% Copyright 2008.
%
% Please see the AUTHORS file for credits.
%
% Website: http://www.cellprofiler.org
%
% $Revision: 5777 $

error(nargchk(2, Inf, nargin, 'struct'));

sepchar = '_';
string = varargin{1};

for i=2:nargin,
   part = varargin{i};
   if isempty(string) || isempty(part)
      string = [string part];
   else
      % Handle the three possible cases
      if (string(end)==sepchar) && (part(1)==sepchar),
         string = [string part(2:end)];
      elseif (string(end)==sepchar) || (part(1)==sepchar )
         string = [string part];
      else
         string = [string sepchar part];
      end
   end
end



function handles = CPaddmeasurements(handles, ObjectName, FeatureName, Data, ImageSetNumber)
% Add measurements of a feature to the handles.Measurements structure.
% Location will be "handles.Measurements.ObjectName.FeatureName".
% ObjectName can be "Image".  
%
% Data can be multiple doubles, or a single string (only if ObjectName is "Image").

%
% CellProfiler is distributed under the GNU General Public License.
% See the accompanying file LICENSE for details.
%
% Developed by the Whitehead Institute for Biomedical Research.
% Copyright 2003,2004,2005.
%
% Please see the AUTHORS file for credits.
%
% Website: http://www.cellprofiler.org
%
% $Revision: 8037 $


if nargin < 5,
    ImageSetNumber = handles.Current.SetBeingAnalyzed;
end

% Check that either this is a new measurement being added in the first
% set, or an old measurement being appended to in a later set.
if isscalar(ImageSetNumber)
	FirstSet = ImageSetNumber == 1;
elseif isvector(ImageSetNumber)
	FirstSet = ImageSetNumber(1) == 1;
end
OldMeasurement = ...
    isfield(handles.Measurements, ObjectName) && ...
    isfield(handles.Measurements.(ObjectName), FeatureName);
BatchProcessing = isfield(handles.Current, 'BatchInfo');

CPvalidfieldname(FeatureName)

%%% Don't allow overwriting of measurements, *except* in batch processing.
if (FirstSet && OldMeasurement && ~BatchProcessing),
    error(['Image processing was canceled because you are attempting to recreate the same measurements, please remove redundant module (#', handles.Current.CurrentModuleNumber, ').']);
end

if (~FirstSet) && (~OldMeasurement) && (~ strcmp(ObjectName, 'Experiment')),
    error(['This should not happen.  CellProfiler Coding Error.  Attempting to add new measurement ', ObjectName, '.',  FeatureName, ' in set ', int2str(ImageSetNumber) ' that was not added in first set.']);
end

%%% Verify we can add this type of Measurement to this type of object
if ischar(Data) && (~ strcmp(ObjectName, 'Image')),
    error(['This should not happen.  CellProfiler Coding Error.  Attempting to add string measurement to non-image ', ObjectName, '.', FeatureName]);
elseif ~strcmp(ObjectName, 'Image') && ~isvector(Data) && ~isempty(Data)
    error(['This should not happen.  CellProfiler Coding Error.  Attempting to add multidimensional (', int2str(size(Data)), ') measurement ', ObjectName, '.', FeatureName]);
elseif strcmp(ObjectName, 'Image') && isnumeric(Data) && ~isscalar(Data),
    error(['This should not happen.  CellProfiler Coding Error.  Attempting to add non-scalar (', int2str(size(Data)), ') measurement to ', ObjectName, '.', FeatureName]);
end


%%% Checks have passed, add the data.
if strcmp(ObjectName, 'Experiment'),
    handles.Measurements.(ObjectName).(FeatureName) = Data;
else
	if isscalar(ImageSetNumber)
		handles.Measurements.(ObjectName).(FeatureName){ImageSetNumber} = Data;
	elseif isvector(ImageSetNumber)
		ImageSetNumber = ImageSetNumber(:)';
		handles.Measurements.(ObjectName).(FeatureName)(ImageSetNumber) = reshape(Data,size(ImageSetNumber));
	end
end
