
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      --><title>calculationPopulationScoreSize</title><meta name="generator" content="MATLAB 7.10"><meta name="date" content="2011-11-07"><meta name="m-file" content="calculationPopulationScoreSize"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><pre class="codeinput"><span class="comment">%This function calculates for a set of cells with population features features2(:,:) their rank in the population</span>
<span class="comment">%method=1:PCA is used to split the population into 10 bins</span>
<span class="comment">%method=2: Thresholds for each feature is used to split up the population:</span>
<span class="comment">%sorted_features: Cell sorted according to bin index</span>
<span class="comment">%bin_starts&gt;Indcies of start of bins used for faster accessing, the last</span>
<span class="comment">%start must be the number of cells in sorted_features</span>
<span class="keyword">function</span> [sorted_coefficients,bin_starts,first_coefficients]=calculationPopulationScoreSize(features2,method,PCA_coefficients)
<span class="comment">%PCA of population contedxt then sortn according to first</span>
                <span class="comment">%component and report PCA of population context</span>
                <span class="keyword">if</span>(method==1)
                scores_population=zeros(size(features2,1),1);
                obj.features2=zscore(features2);
                <span class="keyword">for</span>(i=1:size(obj.features2,1))

                scores_population(i,1)=dot((obj.features2(i,:)),PCA_coefficients(:,1))/norm(PCA_coefficients(:,1));
                <span class="keyword">end</span>;
                [first_coefficients,sorted_coefficients]=sort(scores_population(:,1));

<span class="comment">%                 elseif(method==4)</span>
<span class="comment">%                         %Dynamic binning into LCD bins and split up of each</span>
<span class="comment">%                         %bin into edge/ non-edge</span>
<span class="comment">%</span>
<span class="comment">%                                             lcd_extreme=quantile(features2(:,1),[.025 .975]);</span>
<span class="comment">% distance_extreme=quantile(features2(:,2),[.025  .975]);</span>
<span class="comment">% size_extreme=quantile(features2(:,3),[.025  .975]);</span>
<span class="comment">% z = arrayfun(@(x) (x&lt;lcd_extreme(1))||(x&gt;lcd_extreme(2)),features2(:,1))|arrayfun(@(x) (x&lt;distance_extreme(1))||(x&gt;distance_extreme(2)),features2(:,2))|arrayfun(@(x) (x&lt;size_extreme(1))||(x&gt;size_extreme(2)), features2(:,3));</span>
<span class="comment">%</span>
<span class="comment">%                          lcd_extreme=quantile(features2(:,1), [0.025:0.3166:0.975]);</span>
<span class="comment">%                          [~,bin_indices]=histc(features2(:,1),lcd_extreme(1:4));</span>
<span class="comment">% %                           %Set bin index 4 to 6 due to additon of edge bins</span>
<span class="comment">%  bin_indices(find(bin_indices==3))=5;</span>
<span class="comment">% bin_indices(find(bin_indices==2))=3;</span>
<span class="comment">% %                   %Set bin indices of 3 to 4</span>
<span class="comment">%</span>
<span class="comment">% %                   %Add 1 to the index of celsl in bin and being and edge</span>
<span class="comment">% %                   %cell</span>
<span class="comment">%                    bin_indices(:)=bin_indices(:)+features2(:,2);</span>
<span class="comment">% %                   bin_indices(find(bin_indices==4))=bin_indices(find(bin_indices==4))+features2(find(bin_indices==4),2);</span>
<span class="comment">%                   bin_indices(z)=0;</span>
<span class="comment">%                     %Sort the cells based on the logical vectors</span>
<span class="comment">%                     [first_coefficients,sorted_coefficients]=sort(bin_indices);</span>
<span class="comment">%</span>
<span class="comment">%                     bin_starts=[min(find(first_coefficients==1)),max(find(first_coefficients==1)),max(find(first_coefficients==2)),max(find(first_coefficients==3)),max(find(first_coefficients==4)),max(find(first_coefficients==5)),max(find(first_coefficients==6))];</span>
<span class="comment">%</span>
                                <span class="keyword">elseif</span>(method==4)
                        <span class="comment">%Dynamic binning into LCD bins and split up of each</span>
                        <span class="comment">%bin into edge/ non-edge</span>

<span class="comment">%                                            lcd_extreme=quantile(features2(:,1),[.025 .975]);</span>
        <span class="comment">%     lcd_extreme=quantile(features2(:,1), [0.025:0.3166:0.975]);</span>
                                lcd_extreme=quantile(features2(:,1), [0.0,0.33333,2*0.33333,1]);
                         [~,bin_indices]=histc(features2(:,1),lcd_extreme(1:4));
<span class="comment">%                           %Set bin index 4 to 6 due to additon of edge bins</span>
 bin_indices(find(bin_indices==3))=5;
bin_indices(find(bin_indices==2))=3;
<span class="comment">%                   %Set bin indices of 3 to 4</span>

<span class="comment">%                   %Add 1 to the index of celsl in bin and being and edge</span>
<span class="comment">%                   %cell</span>
                   bin_indices(:)=bin_indices(:)+features2(:,2);
<span class="comment">%                   bin_indices(find(bin_indices==4))=bin_indices(find(bin_indices==4))+features2(find(bin_indices==4),2);</span>
           <span class="comment">%       bin_indices(z)=0;</span>
                    <span class="comment">%Sort the cells based on the logical vectors</span>
                    [first_coefficients,sorted_coefficients]=sort(bin_indices);
                 bin_starts=[1];
                 <span class="keyword">for</span>(bin=2:7)
                     <span class="keyword">if</span>(~isempty(max(find(first_coefficients==bin-1))))
                         <span class="comment">%Bin has some cells add index of last cell to the</span>
                         <span class="comment">%bin_starts vector</span>
                    bin_starts=[bin_starts,max(find(first_coefficients==bin-1))];
                     <span class="keyword">else</span>
                         <span class="comment">%Bin has no cells add just cellend index of last</span>
                         <span class="comment">%bin as end index of this bin. Since there is only</span>
                         <span class="comment">%1 cell in this bin no SVMs wikll be trained</span>
                         bin_starts=[bin_starts,bin_starts(bin-1)];
                     <span class="keyword">end</span>;
                 <span class="keyword">end</span>;
                                                 <span class="keyword">elseif</span>(method==18)
                        <span class="comment">%Dynamic binning into LCD bins and split up of each</span>
                        <span class="comment">%bin into edge/ non-edge</span>

<span class="comment">%                                            lcd_extreme=quantile(features2(:,1),[.025 .975]);</span>
        <span class="comment">%     lcd_extreme=quantile(features2(:,1), [0.025:0.3166:0.975]);</span>
                                lcd_extreme=quantile(features2(:,1), [0.0,0.33333,2*0.33333,1]);
                         [~,bin_indices]=histc(features2(:,1),lcd_extreme(1:4));
<span class="comment">%                           %Set bin index 4 to 6 due to additon of edge bins</span>
 bin_indices(find(bin_indices==3))=13;
bin_indices(find(bin_indices==2))=7;
<span class="comment">%                   %Set bin indices of 3 to 4</span>

<span class="comment">%                   %Add 1 to the index of celsl in bin and being and edge</span>
<span class="comment">%                   %cell</span>
                   bin_indices(:)=bin_indices(:)+features2(:,2)*3;
                   <span class="comment">%Bin into three size bins and add index of bin-1</span>
                           size_extreme=quantile(features2(:,3), [0.0,0.33333,2*0.33333,1]);
                         [~,size_indices]=histc(features2(:,3),size_extreme(1:4));
                   bin_indices=bin_indices+size_indices-1;
<span class="comment">%                   bin_indices(find(bin_indices==4))=bin_indices(find(bin_indices==4))+features2(find(bin_indices==4),2);</span>
           <span class="comment">%       bin_indices(z)=0;</span>
                    <span class="comment">%Sort the cells based on the logical vectors</span>
                    [first_coefficients,sorted_coefficients]=sort(bin_indices);
                 bin_starts=[1];
                 <span class="keyword">for</span>(bin=2:19)
                     <span class="keyword">if</span>(~isempty(max(find(first_coefficients==bin-1))))
                         <span class="comment">%Bin has some cells add index of last cell to the</span>
                         <span class="comment">%bin_starts vector</span>
                    bin_starts=[bin_starts,max(find(first_coefficients==bin-1))];
                     <span class="keyword">else</span>
                         <span class="comment">%Bin has no cells add just cellend index of last</span>
                         <span class="comment">%bin as end index of this bin. Since there is only</span>
                         <span class="comment">%1 cell in this bin no SVMs wikll be trained</span>
                         bin_starts=[bin_starts,bin_starts(bin-1)];
                     <span class="keyword">end</span>;
                 <span class="keyword">end</span>;

                <span class="keyword">elseif</span>(method==5)
                        <span class="comment">%Dynamic binning into 4 LCD binsd and then binning</span>
                        <span class="comment">%of the two middle bins with edge&amp;non/edge</span>
                                            lcd_extreme=quantile(features2(:,1),[.025 .975]);
distance_extreme=quantile(features2(:,2),[.025  .975]);
size_extreme=quantile(features2(:,3),[.025  .975]);
z = arrayfun(@(x) (x&lt;lcd_extreme(1))||(x&gt;lcd_extreme(2)),features2(:,1))|arrayfun(@(x) (x&lt;distance_extreme(1))||(x&gt;distance_extreme(2)),features2(:,2))|arrayfun(@(x) (x&lt;size_extreme(1))||(x&gt;size_extreme(2)), features2(:,3));

                         lcd_extreme=quantile(features2(:,1), [0.025:0.2374:0.975]);
                         [~,bin_indices]=histc(features2(:,1),lcd_extreme(1:5));
<span class="comment">%                           %Set bin index 4 to 6 due to additon of edge bins</span>
<span class="comment">%                   bin_indices(find(bin_indices==4))=6;</span>
<span class="comment">%                   %Set bin indices of 3 to 4</span>
<span class="comment">%                   bin_indices(find(bin_indices==3))=4;</span>
<span class="comment">%                   %Add 1 to the index of celsl in bin and being and edge</span>
<span class="comment">%                   %cell</span>
<span class="comment">%                   bin_indices(find(bin_indices==2))=bin_indices(find(bin_indices==2))+features2(find(bin_indices==2),2);</span>
<span class="comment">%                   bin_indices(find(bin_indices==4))=bin_indices(find(bin_indices==4))+features2(find(bin_indices==4),2);</span>

                <span class="comment">%Set bin index 4 to 6 due to additon of edge bins</span>
                  bin_indices(find(bin_indices==4))=6;
                  <span class="comment">%Set bin indices of 3 to 4</span>
                  bin_indices(find(bin_indices==3))=4;
                  <span class="comment">%Add 1 to the index of celsl in bin and being and edge</span>
                  <span class="comment">%cell</span>
                  bin_indices(find(bin_indices==2))=bin_indices(find(bin_indices==2))+features2(find(bin_indices==2),2);
                  bin_indices(find(bin_indices==4))=bin_indices(find(bin_indices==4))+features2(find(bin_indices==4),2);
bin_indices(z)=0;

                    <span class="comment">%Sort the cells based on the logical vectors</span>
                    [first_coefficients,sorted_coefficients]=sort(bin_indices);

                    bin_starts=[min(find(first_coefficients==1)),max(find(first_coefficients==1)),max(find(first_coefficients==2)),max(find(first_coefficients==3)),max(find(first_coefficients==4)),max(find(first_coefficients==5)),max(find(first_coefficients==6))];
                <span class="keyword">elseif</span>(method==6)
                    <span class="comment">%Return the entire population:1 bin</span>
                    sorted_coefficients=1:size(features2,1)';
                    bin_starts=[1,size(features2,1)];
                <span class="keyword">else</span>
                    lcd_extreme=quantile(features2(:,1),[.025 .975]);
distance_extreme=quantile(features2(:,2),[.025  .975]);
size_extreme=quantile(features2(:,3),[.025  .975]);
z = arrayfun(@(x) (x&lt;lcd_extreme(1))||(x&gt;lcd_extreme(2)),features2(:,1))|arrayfun(@(x) (x&lt;distance_extreme(1))||(x&gt;distance_extreme(2)),features2(:,2))|arrayfun(@(x) (x&lt;size_extreme(1))||(x&gt;size_extreme(2)), features2(:,3));

                    lcd_thresh=[1.53416967954436,2.29621622466132,3.05826276977827,4.15];<span class="comment">%Thresholds obtained from all assay, for better comparabaility this thresholds are hardcoded and obtained from all relevant assays and all plates</span>
                   <span class="comment">%Bin the cells into the 4 LCD bins</span>
                   lcd_edges=[0,lcd_thresh(1)+(lcd_thresh(2)-lcd_thresh(1))/2,lcd_thresh(2)+(lcd_thresh(3)-lcd_thresh(2))/2,lcd_thresh(3)+(lcd_thresh(4)-lcd_thresh(3))/2,10]
                  <span class="comment">%Calculate bin index of each cell</span>
                  [~,bin_indices]=histc(features2(:,1),lcd_edges);
                  <span class="comment">%Set bin index 4 to 6 due to additon of edge bins</span>
                  bin_indices(find(bin_indices==4))=6;
                  <span class="comment">%Set bin indices of 3 to 4</span>
                  bin_indices(find(bin_indices==3))=4;
                  <span class="comment">%Add 1 to the index of celsl in bin and being and edge</span>
                  <span class="comment">%cell</span>
                  bin_indices(find(bin_indices==2))=bin_indices(find(bin_indices==2))+features2(find(bin_indices==2),2);
                  bin_indices(find(bin_indices==4))=bin_indices(find(bin_indices==4))+features2(find(bin_indices==4),2);
                  bin_indices(z)=0;
                    <span class="comment">%Sort the cells based on the logical vectors</span>
                    [first_coefficients,sorted_coefficients]=sort(bin_indices);

                    bin_starts=[min(find(first_coefficients==1)),max(find(first_coefficients==1)),max(find(first_coefficients==2)),max(find(first_coefficients==3)),max(find(first_coefficients==4)),max(find(first_coefficients==5)),max(find(first_coefficients==6))];
                <span class="keyword">end</span>;
<span class="keyword">end</span>
</pre><pre class="codeoutput">Input argument "method" is undefined.

Error in ==&gt; calculationPopulationScoreSize at 10
                if(method==1)
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.10<br></p></div><!--
##### SOURCE BEGIN #####
%This function calculates for a set of cells with population features features2(:,:) their rank in the population
%method=1:PCA is used to split the population into 10 bins
%method=2: Thresholds for each feature is used to split up the population:
%sorted_features: Cell sorted according to bin index
%bin_starts>Indcies of start of bins used for faster accessing, the last
%start must be the number of cells in sorted_features
function [sorted_coefficients,bin_starts,first_coefficients]=calculationPopulationScoreSize(features2,method,PCA_coefficients)
%PCA of population contedxt then sortn according to first
                %component and report PCA of population context
                if(method==1)
                scores_population=zeros(size(features2,1),1);
                obj.features2=zscore(features2);
                for(i=1:size(obj.features2,1))
                    
                scores_population(i,1)=dot((obj.features2(i,:)),PCA_coefficients(:,1))/norm(PCA_coefficients(:,1));
                end;
                [first_coefficients,sorted_coefficients]=sort(scores_population(:,1));
                
%                 elseif(method==4)
%                         %Dynamic binning into LCD bins and split up of each
%                         %bin into edge/ non-edge
%                       
%                                             lcd_extreme=quantile(features2(:,1),[.025 .975]);
% distance_extreme=quantile(features2(:,2),[.025  .975]);
% size_extreme=quantile(features2(:,3),[.025  .975]);
% z = arrayfun(@(x) (x<lcd_extreme(1))||(x>lcd_extreme(2)),features2(:,1))|arrayfun(@(x) (x<distance_extreme(1))||(x>distance_extreme(2)),features2(:,2))|arrayfun(@(x) (x<size_extreme(1))||(x>size_extreme(2)), features2(:,3));
% 
%                          lcd_extreme=quantile(features2(:,1), [0.025:0.3166:0.975]);
%                          [~,bin_indices]=histc(features2(:,1),lcd_extreme(1:4));
% %                           %Set bin index 4 to 6 due to additon of edge bins
%  bin_indices(find(bin_indices==3))=5;                   
% bin_indices(find(bin_indices==2))=3;
% %                   %Set bin indices of 3 to 4
%                  
% %                   %Add 1 to the index of celsl in bin and being and edge
% %                   %cell
%                    bin_indices(:)=bin_indices(:)+features2(:,2);
% %                   bin_indices(find(bin_indices==4))=bin_indices(find(bin_indices==4))+features2(find(bin_indices==4),2);
%                   bin_indices(z)=0;
%                     %Sort the cells based on the logical vectors
%                     [first_coefficients,sorted_coefficients]=sort(bin_indices);
%                  
%                     bin_starts=[min(find(first_coefficients==1)),max(find(first_coefficients==1)),max(find(first_coefficients==2)),max(find(first_coefficients==3)),max(find(first_coefficients==4)),max(find(first_coefficients==5)),max(find(first_coefficients==6))];
%                  
                                elseif(method==4)
                        %Dynamic binning into LCD bins and split up of each
                        %bin into edge/ non-edge
                      
%                                            lcd_extreme=quantile(features2(:,1),[.025 .975]);
        %     lcd_extreme=quantile(features2(:,1), [0.025:0.3166:0.975]);
                                lcd_extreme=quantile(features2(:,1), [0.0,0.33333,2*0.33333,1]);
                         [~,bin_indices]=histc(features2(:,1),lcd_extreme(1:4));
%                           %Set bin index 4 to 6 due to additon of edge bins
 bin_indices(find(bin_indices==3))=5;                   
bin_indices(find(bin_indices==2))=3;
%                   %Set bin indices of 3 to 4
                 
%                   %Add 1 to the index of celsl in bin and being and edge
%                   %cell
                   bin_indices(:)=bin_indices(:)+features2(:,2);
%                   bin_indices(find(bin_indices==4))=bin_indices(find(bin_indices==4))+features2(find(bin_indices==4),2);
           %       bin_indices(z)=0;
                    %Sort the cells based on the logical vectors
                    [first_coefficients,sorted_coefficients]=sort(bin_indices);
                 bin_starts=[1];
                 for(bin=2:7)
                     if(~isempty(max(find(first_coefficients==bin-1))))
                         %Bin has some cells add index of last cell to the
                         %bin_starts vector
                    bin_starts=[bin_starts,max(find(first_coefficients==bin-1))];
                     else
                         %Bin has no cells add just cellend index of last
                         %bin as end index of this bin. Since there is only
                         %1 cell in this bin no SVMs wikll be trained
                         bin_starts=[bin_starts,bin_starts(bin-1)];
                     end;
                 end;
                                                 elseif(method==18)
                        %Dynamic binning into LCD bins and split up of each
                        %bin into edge/ non-edge
                      
%                                            lcd_extreme=quantile(features2(:,1),[.025 .975]);
        %     lcd_extreme=quantile(features2(:,1), [0.025:0.3166:0.975]);
                                lcd_extreme=quantile(features2(:,1), [0.0,0.33333,2*0.33333,1]);
                         [~,bin_indices]=histc(features2(:,1),lcd_extreme(1:4));
%                           %Set bin index 4 to 6 due to additon of edge bins
 bin_indices(find(bin_indices==3))=13;                   
bin_indices(find(bin_indices==2))=7;
%                   %Set bin indices of 3 to 4
                 
%                   %Add 1 to the index of celsl in bin and being and edge
%                   %cell
                   bin_indices(:)=bin_indices(:)+features2(:,2)*3;
                   %Bin into three size bins and add index of bin-1
                           size_extreme=quantile(features2(:,3), [0.0,0.33333,2*0.33333,1]);
                         [~,size_indices]=histc(features2(:,3),size_extreme(1:4));
                   bin_indices=bin_indices+size_indices-1;
%                   bin_indices(find(bin_indices==4))=bin_indices(find(bin_indices==4))+features2(find(bin_indices==4),2);
           %       bin_indices(z)=0;
                    %Sort the cells based on the logical vectors
                    [first_coefficients,sorted_coefficients]=sort(bin_indices);
                 bin_starts=[1];
                 for(bin=2:19)
                     if(~isempty(max(find(first_coefficients==bin-1))))
                         %Bin has some cells add index of last cell to the
                         %bin_starts vector
                    bin_starts=[bin_starts,max(find(first_coefficients==bin-1))];
                     else
                         %Bin has no cells add just cellend index of last
                         %bin as end index of this bin. Since there is only
                         %1 cell in this bin no SVMs wikll be trained
                         bin_starts=[bin_starts,bin_starts(bin-1)];
                     end;
                 end;
                        
                elseif(method==5)
                        %Dynamic binning into 4 LCD binsd and then binning
                        %of the two middle bins with edge&non/edge
                                            lcd_extreme=quantile(features2(:,1),[.025 .975]);
distance_extreme=quantile(features2(:,2),[.025  .975]);
size_extreme=quantile(features2(:,3),[.025  .975]);
z = arrayfun(@(x) (x<lcd_extreme(1))||(x>lcd_extreme(2)),features2(:,1))|arrayfun(@(x) (x<distance_extreme(1))||(x>distance_extreme(2)),features2(:,2))|arrayfun(@(x) (x<size_extreme(1))||(x>size_extreme(2)), features2(:,3));

                         lcd_extreme=quantile(features2(:,1), [0.025:0.2374:0.975]);
                         [~,bin_indices]=histc(features2(:,1),lcd_extreme(1:5));
%                           %Set bin index 4 to 6 due to additon of edge bins
%                   bin_indices(find(bin_indices==4))=6;
%                   %Set bin indices of 3 to 4
%                   bin_indices(find(bin_indices==3))=4;
%                   %Add 1 to the index of celsl in bin and being and edge
%                   %cell
%                   bin_indices(find(bin_indices==2))=bin_indices(find(bin_indices==2))+features2(find(bin_indices==2),2);
%                   bin_indices(find(bin_indices==4))=bin_indices(find(bin_indices==4))+features2(find(bin_indices==4),2);
                  
                %Set bin index 4 to 6 due to additon of edge bins
                  bin_indices(find(bin_indices==4))=6;
                  %Set bin indices of 3 to 4
                  bin_indices(find(bin_indices==3))=4;
                  %Add 1 to the index of celsl in bin and being and edge
                  %cell
                  bin_indices(find(bin_indices==2))=bin_indices(find(bin_indices==2))+features2(find(bin_indices==2),2);
                  bin_indices(find(bin_indices==4))=bin_indices(find(bin_indices==4))+features2(find(bin_indices==4),2);
bin_indices(z)=0;
                  
                    %Sort the cells based on the logical vectors
                    [first_coefficients,sorted_coefficients]=sort(bin_indices);
                 
                    bin_starts=[min(find(first_coefficients==1)),max(find(first_coefficients==1)),max(find(first_coefficients==2)),max(find(first_coefficients==3)),max(find(first_coefficients==4)),max(find(first_coefficients==5)),max(find(first_coefficients==6))];
                elseif(method==6)
                    %Return the entire population:1 bin
                    sorted_coefficients=1:size(features2,1)';
                    bin_starts=[1,size(features2,1)];
                else
                    lcd_extreme=quantile(features2(:,1),[.025 .975]);
distance_extreme=quantile(features2(:,2),[.025  .975]);
size_extreme=quantile(features2(:,3),[.025  .975]);
z = arrayfun(@(x) (x<lcd_extreme(1))||(x>lcd_extreme(2)),features2(:,1))|arrayfun(@(x) (x<distance_extreme(1))||(x>distance_extreme(2)),features2(:,2))|arrayfun(@(x) (x<size_extreme(1))||(x>size_extreme(2)), features2(:,3));

                    lcd_thresh=[1.53416967954436,2.29621622466132,3.05826276977827,4.15];%Thresholds obtained from all assay, for better comparabaility this thresholds are hardcoded and obtained from all relevant assays and all plates
                   %Bin the cells into the 4 LCD bins
                   lcd_edges=[0,lcd_thresh(1)+(lcd_thresh(2)-lcd_thresh(1))/2,lcd_thresh(2)+(lcd_thresh(3)-lcd_thresh(2))/2,lcd_thresh(3)+(lcd_thresh(4)-lcd_thresh(3))/2,10]
                  %Calculate bin index of each cell
                  [~,bin_indices]=histc(features2(:,1),lcd_edges);
                  %Set bin index 4 to 6 due to additon of edge bins
                  bin_indices(find(bin_indices==4))=6;
                  %Set bin indices of 3 to 4
                  bin_indices(find(bin_indices==3))=4;
                  %Add 1 to the index of celsl in bin and being and edge
                  %cell
                  bin_indices(find(bin_indices==2))=bin_indices(find(bin_indices==2))+features2(find(bin_indices==2),2);
                  bin_indices(find(bin_indices==4))=bin_indices(find(bin_indices==4))+features2(find(bin_indices==4),2);
                  bin_indices(z)=0;
                    %Sort the cells based on the logical vectors
                    [first_coefficients,sorted_coefficients]=sort(bin_indices);
                 
                    bin_starts=[min(find(first_coefficients==1)),max(find(first_coefficients==1)),max(find(first_coefficients==2)),max(find(first_coefficients==3)),max(find(first_coefficients==4)),max(find(first_coefficients==5)),max(find(first_coefficients==6))];
                end;
end
     
                
##### SOURCE END #####
--></body></html>